# -*- coding: utf-8 -*-

from random import randint

# TODO: Что такое "движок игры"?
#  Это ядро из методов, которые образуют правила игры. Это можно сказать суть игры.
#  Например играть в дурака можно в живую, можно онлайн. Интерфейс взаимодействия будет разный: мышка или держим карты
#  в руках. Но правила игры буду неизменны.
#  .
#  В данном случае, у игры может быть графический или консольный интерфейс, но у обоих версий (графической и консольной)
#  должен быть единый движок (буквально один и тот же файл с одними и теми же методами). Поэтому все моменты
#  взаимодействия с пользователем - выносим в файл 01_mastermind.py. В движке не должно быть ни одного print(),
#  ни одного input().



_generated_number = {}
_sorted_keys = []

# TODO: Константа NUMB_OF_DIGITS.
#  Добавьте глобальную константу "ЧИСЛО ЦИФР В ЧИСЛЕ", которая будет равна 4. Используйте эту константу по коду,
#  чтобы иметь возможность одним движением изменить настройки игры (сейчас у нас в интерфейсе (файл 01_mastermind.py),
#  жестко задана 4ка и здесь по коду раскидано 4. Это затрудняет нам возможность быстро модифицировать код, если потребуется).


#   загадать_число()
def get_number():
    global _generated_number, _sorted_keys
    # TODO:

    for i in range(1, 5):
        if i == 1:
            _generated_number[i] = randint(1, 9)
            continue
        new_number = 0
        number_repeat = True
        while number_repeat:
            new_number = randint(0, 9)
            number_repeat = False
            for j in _generated_number:
                if _generated_number[j] == new_number:
                    number_repeat = True
        _generated_number[i] = new_number
    _sorted_keys = sorted(_generated_number.keys())

# TODO: Если применить sample(), то получим компактную версию. Пример работы sample()
#       random.sample(list(range(100500)), 7)		# вернет список из 7 рандомных чисел из 100500 чисел

# TODO: а можно сделать в 4 строки, если учесть следующее:
#  sample может работать со строками, и выбирать из них рандонмые символы.
#  Что пригодится: pop; append; '0123456789'
#  .
#  Подсказка: пусть sample сразу генерирует число из 4 чисел. Потом надо разобраться как быть, если первое число - ноль.

# TODO: Это не функцию движка.
def print_number():
    number = ''

    for key in _sorted_keys:
        number += str(_generated_number[key])
    print(number)


#   проверить_число(NN) - возвращает словарь {'bulls': N, 'cows': N}
def check_number(enter_number):
    dict_enter_number = {}
    bulls_and_cows = {'bulls': 0, 'cows': 0}

    # TODO: Это неоправданное усложнение кода.
    #  Только с поправкой на то, что вы написали, что это специально для закрепления знаний, мы оставим.
    #  Но превращать список в словарь не стоит.
    #  А хранить отсортированные ключи словаря - это вообще нонсанс.
    #  .
    #  Как тогда получить отсортированные данные из словаря?
    #  Использовать параметр 'key' у функции sorted.
    #  Пусть есть словарь d, скормим его .items() функции sorted() и посмотрим что вышло:
    #       d = {'b': 1, 'a': 2, 'c':3}
    #       print(sorted(d.items()))            # [('a', 2), ('b', 1), ('c', 3)]
    #  .
    #  Ф-ция сортировки отсортировала список пар. Каждая пара ключ-значения представлена в виде кортежа.
    #  .
    #  Когда мы добавляем 'key', мы указываем, что сортировать нужно по какому-то критерию, который должен
    #  высчитываться для каждого элемента списка, т.е. для каждой пары.
    #  Пример:
    #       # импортируем функцию, которая принимает индекс и выдает значение по нему, можно сказать
    #       # что itemgetter - это и есть квадратные скобки '[]'
    #       from operator import itemgetter
    #       .
    #       # .items() возвращает пары ключ-значение в виде кортежей. Поэтому здесь происходит сортировка
    #       # списка пар ключ-значение. При этом в качестве ключа (критерия) кортировки берется значение,
    #       # которое возвращает itemgetter для 1го (не 0го, а 1го) элемента. Т.е. для значения списка.
    #       sorted(d.items(), key=itemgetter(1))
    #  .
    #  itemgetter(1) берет каждую пару и возвращает последний элемент: 2, 1, 3. Получив критерии по которым
    #  нужно сортировать элементы, функция sort выполняет сортировку:
    #        print(sorted(d.items(), key=itemgetter(1)))           # [('b', 1), ('a', 2), ('c', 3)]
    #  .
    #  В итоге, мы получаем список из котрежей, где 0ое значение - значения словаря, а 1ое значение - ключ
    #  словаря. При этом, этот набор отсортирован по значениям! То, что нужно)
    #  .
    #  Сортировать словарь - непростая задача. Совсем. Есть более удобный способ, но он еще более сложный,
    #  использует словарные включения. Поэтому мы пока остановимся на этом способе.

    for i, number in enumerate(enter_number):
        dict_enter_number[_sorted_keys[i]] = int(number)

    for i in _sorted_keys:
        if dict_enter_number[i] == _generated_number[i]:
            bulls_and_cows['bulls'] += 1
        # TODO: используйте elif, проверить входит ли буква в число. Тогда 5 строк ниже можно превратить в 2
        for j in _generated_number:
            if dict_enter_number[i] == _generated_number[j]:
                bulls_and_cows['cows'] += 1
    if bulls_and_cows['bulls'] != 0:
        bulls_and_cows['cows'] -= bulls_and_cows['bulls']

    return bulls_and_cows
